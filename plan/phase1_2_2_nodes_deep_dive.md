
# 阶段一：核心概念 | 2.2. 详解核心组件：Nodes

**目标：** 掌握 LangGraph 节点（Nodes）的定义、输入输出契约，并理解如何设计出功能明确、可复用的节点。

---

## Nodes: 图的“工人”

如果说 State 是图的“蓝图”和“血液”，那么 Nodes 就是执行具体任务的“工人”。每个节点都是一个独立的、可调用的单元，负责执行工作流中的一个步骤。

在 LangGraph 中，一个节点通常就是一个 Python 函数。

--- 

## 节点的输入/输出契约

每个 LangGraph 节点都必须严格遵守一个简单而清晰的输入/输出契约：

-   **输入 (Input):** 节点函数**必须**接收一个参数，这个参数就是当前图的**完整状态对象**（通常是一个 `TypedDict`）。这是节点获取所需上下文和数据的唯一来源。

-   **输出 (Output):** 节点函数**必须**返回一个**字典**。这个字典是该节点对状态的**更新补丁 (Update Patch)**。LangGraph 会将这个返回的字典合并（`update`）到主状态中。

### 契约的强制性

这个契约是强制性的。如果你的函数不接收状态作为参数，或者返回值不是一个字典，LangGraph 在编译或运行时会抛出错误。

```python
from typing import TypedDict

# 定义 State
class AgentState(TypedDict):
    input: str
    output: str | None

# --- 正确的节点定义 ---
def correct_node(state: AgentState) -> dict:
    # 接收 state, 返回 dict
    print(f"Input is: {state['input']}")
    return {"output": "This is a correct output."}

# --- 错误的节点定义 ---
# def wrong_node_no_input(): # 错误：没有接收 state 参数
#     return {"output": "..."}

# def wrong_node_wrong_return(state: AgentState) -> str: # 错误：返回值不是 dict
#     return "a string, not a dict"
```

--- 

## 设计好的节点：单一职责原则

在设计节点时，应遵循**单一职责原则 (Single Responsibility Principle)**。这意味着每个节点应该只做一件定义明确的事情。

-   **反例 (Bad Practice):** 一个节点既调用 LLM，又解析结果，还调用工具，最后又格式化输出。这种节点耦合度太高，难以测试和复用。

-   **正例 (Good Practice):** 将上述逻辑拆分为多个节点：
    -   `agent` 节点: 负责调用 LLM 并决定下一步行动。
    -   `tool_executor` 节点: 负责执行工具调用。
    -   `output_formatter` 节点: 负责将最终结果格式化为用户友好的形式。

### 拆分的好处

| 优点 | 描述 |
| :--- | :--- |
| **可复用性** | `tool_executor` 节点可以在多个不同的工作流中被复用。 |
| **可测试性** | 你可以独立地为每个节点编写单元测试，确保其功能的正确性。 |
| **可读性/可维护性** | 每个节点的功能都清晰明了，当工作流出问题时，可以快速定位到是哪个“工人”出了问题。 |
| **灵活性** | 你可以轻松地在 `agent` 和 `tool_executor` 之间插入一个新的 `human_in_the_loop` (人工干预) 节点，而无需修改原有节点的代码。 |

--- 

## 幂等性 (Idempotence): 一个好的设计目标

**幂等性**是指一个操作执行一次和执行多次产生的效果是相同的。在设计 LangGraph 节点时，追求幂等性是一个很好的目标，尽管不总是能完全实现。

**为什么重要？** LangGraph 的 `Checkpointer` 机制可以保存每一步的状态。如果你的某个节点执行失败，你可能需要从上一步的状态恢复并重新执行该节点。如果这个节点是幂等的，重试就不会产生意料之外的副作用。

**如何实现？**
-   **读取-计算-返回:** 节点应该主要基于其输入状态进行计算，并返回结果，尽量避免修改外部系统（除非该外部系统操作本身是幂等的，如 `create_or_update`）。
-   **避免副作用:** 节点函数应尽量减少“副作用”，比如向一个没有幂等性保证的外部 API 发送请求。如果必须有副作用，应将其隔离在特定的、设计精良的节点中。

**示例:**

-   **幂等节点:** 一个接收数字列表并返回其总和的节点是幂等的。无论你用同一个列表调用它多少次，结果总是一样的。
-   **非幂等节点:** 一个向数据库中 `INSERT` 一条新记录的节点是非幂等的。每调用一次，就会多一条记录。

虽然不强求所有节点都幂等，但在设计时心中有这个概念，可以帮助你构建出更可靠、更可预测的工作流。
